// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"go-bponline/m/gen/model"
)

func newTPerguruanTinggi(db *gorm.DB, opts ...gen.DOOption) tPerguruanTinggi {
	_tPerguruanTinggi := tPerguruanTinggi{}

	_tPerguruanTinggi.tPerguruanTinggiDo.UseDB(db, opts...)
	_tPerguruanTinggi.tPerguruanTinggiDo.UseModel(&model.TPerguruanTinggi{})

	tableName := _tPerguruanTinggi.tPerguruanTinggiDo.TableName()
	_tPerguruanTinggi.ALL = field.NewAsterisk(tableName)
	_tPerguruanTinggi.CIDPerguruanTinggi = field.NewInt32(tableName, "c_id_perguruan_tinggi")
	_tPerguruanTinggi.CIDDistrict = field.NewInt32(tableName, "c_id_district")
	_tPerguruanTinggi.CNamaPerguruanTinggi = field.NewString(tableName, "c_nama_perguruan_tinggi")
	_tPerguruanTinggi.CAkronim = field.NewString(tableName, "c_akronim")
	_tPerguruanTinggi.CJenis = field.NewString(tableName, "c_jenis")
	_tPerguruanTinggi.CIsInternasional = field.NewString(tableName, "c_is_internasional")
	_tPerguruanTinggi.CStatus = field.NewString(tableName, "c_status")
	_tPerguruanTinggi.CUpdater = field.NewString(tableName, "c_updater")
	_tPerguruanTinggi.CCreatedAt = field.NewTime(tableName, "c_created_at")
	_tPerguruanTinggi.CLastUpdate = field.NewTime(tableName, "c_last_update")

	_tPerguruanTinggi.fillFieldMap()

	return _tPerguruanTinggi
}

type tPerguruanTinggi struct {
	tPerguruanTinggiDo

	ALL                  field.Asterisk
	CIDPerguruanTinggi   field.Int32
	CIDDistrict          field.Int32
	CNamaPerguruanTinggi field.String
	CAkronim             field.String
	CJenis               field.String
	CIsInternasional     field.String
	CStatus              field.String
	CUpdater             field.String
	CCreatedAt           field.Time
	CLastUpdate          field.Time

	fieldMap map[string]field.Expr
}

func (t tPerguruanTinggi) Table(newTableName string) *tPerguruanTinggi {
	t.tPerguruanTinggiDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tPerguruanTinggi) As(alias string) *tPerguruanTinggi {
	t.tPerguruanTinggiDo.DO = *(t.tPerguruanTinggiDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tPerguruanTinggi) updateTableName(table string) *tPerguruanTinggi {
	t.ALL = field.NewAsterisk(table)
	t.CIDPerguruanTinggi = field.NewInt32(table, "c_id_perguruan_tinggi")
	t.CIDDistrict = field.NewInt32(table, "c_id_district")
	t.CNamaPerguruanTinggi = field.NewString(table, "c_nama_perguruan_tinggi")
	t.CAkronim = field.NewString(table, "c_akronim")
	t.CJenis = field.NewString(table, "c_jenis")
	t.CIsInternasional = field.NewString(table, "c_is_internasional")
	t.CStatus = field.NewString(table, "c_status")
	t.CUpdater = field.NewString(table, "c_updater")
	t.CCreatedAt = field.NewTime(table, "c_created_at")
	t.CLastUpdate = field.NewTime(table, "c_last_update")

	t.fillFieldMap()

	return t
}

func (t *tPerguruanTinggi) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tPerguruanTinggi) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 10)
	t.fieldMap["c_id_perguruan_tinggi"] = t.CIDPerguruanTinggi
	t.fieldMap["c_id_district"] = t.CIDDistrict
	t.fieldMap["c_nama_perguruan_tinggi"] = t.CNamaPerguruanTinggi
	t.fieldMap["c_akronim"] = t.CAkronim
	t.fieldMap["c_jenis"] = t.CJenis
	t.fieldMap["c_is_internasional"] = t.CIsInternasional
	t.fieldMap["c_status"] = t.CStatus
	t.fieldMap["c_updater"] = t.CUpdater
	t.fieldMap["c_created_at"] = t.CCreatedAt
	t.fieldMap["c_last_update"] = t.CLastUpdate
}

func (t tPerguruanTinggi) clone(db *gorm.DB) tPerguruanTinggi {
	t.tPerguruanTinggiDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tPerguruanTinggi) replaceDB(db *gorm.DB) tPerguruanTinggi {
	t.tPerguruanTinggiDo.ReplaceDB(db)
	return t
}

type tPerguruanTinggiDo struct{ gen.DO }

type ITPerguruanTinggiDo interface {
	gen.SubQuery
	Debug() ITPerguruanTinggiDo
	WithContext(ctx context.Context) ITPerguruanTinggiDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITPerguruanTinggiDo
	WriteDB() ITPerguruanTinggiDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITPerguruanTinggiDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITPerguruanTinggiDo
	Not(conds ...gen.Condition) ITPerguruanTinggiDo
	Or(conds ...gen.Condition) ITPerguruanTinggiDo
	Select(conds ...field.Expr) ITPerguruanTinggiDo
	Where(conds ...gen.Condition) ITPerguruanTinggiDo
	Order(conds ...field.Expr) ITPerguruanTinggiDo
	Distinct(cols ...field.Expr) ITPerguruanTinggiDo
	Omit(cols ...field.Expr) ITPerguruanTinggiDo
	Join(table schema.Tabler, on ...field.Expr) ITPerguruanTinggiDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITPerguruanTinggiDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITPerguruanTinggiDo
	Group(cols ...field.Expr) ITPerguruanTinggiDo
	Having(conds ...gen.Condition) ITPerguruanTinggiDo
	Limit(limit int) ITPerguruanTinggiDo
	Offset(offset int) ITPerguruanTinggiDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITPerguruanTinggiDo
	Unscoped() ITPerguruanTinggiDo
	Create(values ...*model.TPerguruanTinggi) error
	CreateInBatches(values []*model.TPerguruanTinggi, batchSize int) error
	Save(values ...*model.TPerguruanTinggi) error
	First() (*model.TPerguruanTinggi, error)
	Take() (*model.TPerguruanTinggi, error)
	Last() (*model.TPerguruanTinggi, error)
	Find() ([]*model.TPerguruanTinggi, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TPerguruanTinggi, err error)
	FindInBatches(result *[]*model.TPerguruanTinggi, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TPerguruanTinggi) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITPerguruanTinggiDo
	Assign(attrs ...field.AssignExpr) ITPerguruanTinggiDo
	Joins(fields ...field.RelationField) ITPerguruanTinggiDo
	Preload(fields ...field.RelationField) ITPerguruanTinggiDo
	FirstOrInit() (*model.TPerguruanTinggi, error)
	FirstOrCreate() (*model.TPerguruanTinggi, error)
	FindByPage(offset int, limit int) (result []*model.TPerguruanTinggi, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITPerguruanTinggiDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tPerguruanTinggiDo) Debug() ITPerguruanTinggiDo {
	return t.withDO(t.DO.Debug())
}

func (t tPerguruanTinggiDo) WithContext(ctx context.Context) ITPerguruanTinggiDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tPerguruanTinggiDo) ReadDB() ITPerguruanTinggiDo {
	return t.Clauses(dbresolver.Read)
}

func (t tPerguruanTinggiDo) WriteDB() ITPerguruanTinggiDo {
	return t.Clauses(dbresolver.Write)
}

func (t tPerguruanTinggiDo) Session(config *gorm.Session) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Session(config))
}

func (t tPerguruanTinggiDo) Clauses(conds ...clause.Expression) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tPerguruanTinggiDo) Returning(value interface{}, columns ...string) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tPerguruanTinggiDo) Not(conds ...gen.Condition) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tPerguruanTinggiDo) Or(conds ...gen.Condition) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tPerguruanTinggiDo) Select(conds ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tPerguruanTinggiDo) Where(conds ...gen.Condition) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tPerguruanTinggiDo) Order(conds ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tPerguruanTinggiDo) Distinct(cols ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tPerguruanTinggiDo) Omit(cols ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tPerguruanTinggiDo) Join(table schema.Tabler, on ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tPerguruanTinggiDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tPerguruanTinggiDo) RightJoin(table schema.Tabler, on ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tPerguruanTinggiDo) Group(cols ...field.Expr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tPerguruanTinggiDo) Having(conds ...gen.Condition) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tPerguruanTinggiDo) Limit(limit int) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tPerguruanTinggiDo) Offset(offset int) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tPerguruanTinggiDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tPerguruanTinggiDo) Unscoped() ITPerguruanTinggiDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tPerguruanTinggiDo) Create(values ...*model.TPerguruanTinggi) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tPerguruanTinggiDo) CreateInBatches(values []*model.TPerguruanTinggi, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tPerguruanTinggiDo) Save(values ...*model.TPerguruanTinggi) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tPerguruanTinggiDo) First() (*model.TPerguruanTinggi, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TPerguruanTinggi), nil
	}
}

func (t tPerguruanTinggiDo) Take() (*model.TPerguruanTinggi, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TPerguruanTinggi), nil
	}
}

func (t tPerguruanTinggiDo) Last() (*model.TPerguruanTinggi, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TPerguruanTinggi), nil
	}
}

func (t tPerguruanTinggiDo) Find() ([]*model.TPerguruanTinggi, error) {
	result, err := t.DO.Find()
	return result.([]*model.TPerguruanTinggi), err
}

func (t tPerguruanTinggiDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TPerguruanTinggi, err error) {
	buf := make([]*model.TPerguruanTinggi, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tPerguruanTinggiDo) FindInBatches(result *[]*model.TPerguruanTinggi, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tPerguruanTinggiDo) Attrs(attrs ...field.AssignExpr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tPerguruanTinggiDo) Assign(attrs ...field.AssignExpr) ITPerguruanTinggiDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tPerguruanTinggiDo) Joins(fields ...field.RelationField) ITPerguruanTinggiDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tPerguruanTinggiDo) Preload(fields ...field.RelationField) ITPerguruanTinggiDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tPerguruanTinggiDo) FirstOrInit() (*model.TPerguruanTinggi, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TPerguruanTinggi), nil
	}
}

func (t tPerguruanTinggiDo) FirstOrCreate() (*model.TPerguruanTinggi, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TPerguruanTinggi), nil
	}
}

func (t tPerguruanTinggiDo) FindByPage(offset int, limit int) (result []*model.TPerguruanTinggi, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tPerguruanTinggiDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tPerguruanTinggiDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tPerguruanTinggiDo) Delete(models ...*model.TPerguruanTinggi) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tPerguruanTinggiDo) withDO(do gen.Dao) *tPerguruanTinggiDo {
	t.DO = *do.(*gen.DO)
	return t
}
