// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"go-bponline/m/gen/model"
)

func newTUtbkHeader(db *gorm.DB, opts ...gen.DOOption) tUtbkHeader {
	_tUtbkHeader := tUtbkHeader{}

	_tUtbkHeader.tUtbkHeaderDo.UseDB(db, opts...)
	_tUtbkHeader.tUtbkHeaderDo.UseModel(&model.TUtbkHeader{})

	tableName := _tUtbkHeader.tUtbkHeaderDo.TableName()
	_tUtbkHeader.ALL = field.NewAsterisk(tableName)
	_tUtbkHeader.CNis = field.NewString(tableName, "c_nis")
	_tUtbkHeader.CNoUtbk = field.NewString(tableName, "c_no_utbk")
	_tUtbkHeader.CKodeGedung = field.NewInt32(tableName, "c_kode_gedung")
	_tUtbkHeader.CNamaSiswa = field.NewString(tableName, "c_nama_siswa")
	_tUtbkHeader.CNilai = field.NewFloat64(tableName, "c_nilai")
	_tUtbkHeader.CKelompok = field.NewString(tableName, "c_kelompok")
	_tUtbkHeader.CSesi = field.NewString(tableName, "c_sesi")
	_tUtbkHeader.CTglUpload = field.NewTime(tableName, "c_tgl_upload")
	_tUtbkHeader.CTglTampil = field.NewTime(tableName, "c_tgl_tampil")
	_tUtbkHeader.CTglTutup = field.NewTime(tableName, "c_tgl_tutup")
	_tUtbkHeader.CEditNilai = field.NewString(tableName, "c_edit_nilai")
	_tUtbkHeader.CUpdater = field.NewString(tableName, "c_updater")

	_tUtbkHeader.fillFieldMap()

	return _tUtbkHeader
}

type tUtbkHeader struct {
	tUtbkHeaderDo

	ALL         field.Asterisk
	CNis        field.String
	CNoUtbk     field.String
	CKodeGedung field.Int32
	CNamaSiswa  field.String
	CNilai      field.Float64
	CKelompok   field.String
	CSesi       field.String
	CTglUpload  field.Time
	CTglTampil  field.Time
	CTglTutup   field.Time
	CEditNilai  field.String
	CUpdater    field.String

	fieldMap map[string]field.Expr
}

func (t tUtbkHeader) Table(newTableName string) *tUtbkHeader {
	t.tUtbkHeaderDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tUtbkHeader) As(alias string) *tUtbkHeader {
	t.tUtbkHeaderDo.DO = *(t.tUtbkHeaderDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tUtbkHeader) updateTableName(table string) *tUtbkHeader {
	t.ALL = field.NewAsterisk(table)
	t.CNis = field.NewString(table, "c_nis")
	t.CNoUtbk = field.NewString(table, "c_no_utbk")
	t.CKodeGedung = field.NewInt32(table, "c_kode_gedung")
	t.CNamaSiswa = field.NewString(table, "c_nama_siswa")
	t.CNilai = field.NewFloat64(table, "c_nilai")
	t.CKelompok = field.NewString(table, "c_kelompok")
	t.CSesi = field.NewString(table, "c_sesi")
	t.CTglUpload = field.NewTime(table, "c_tgl_upload")
	t.CTglTampil = field.NewTime(table, "c_tgl_tampil")
	t.CTglTutup = field.NewTime(table, "c_tgl_tutup")
	t.CEditNilai = field.NewString(table, "c_edit_nilai")
	t.CUpdater = field.NewString(table, "c_updater")

	t.fillFieldMap()

	return t
}

func (t *tUtbkHeader) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tUtbkHeader) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 12)
	t.fieldMap["c_nis"] = t.CNis
	t.fieldMap["c_no_utbk"] = t.CNoUtbk
	t.fieldMap["c_kode_gedung"] = t.CKodeGedung
	t.fieldMap["c_nama_siswa"] = t.CNamaSiswa
	t.fieldMap["c_nilai"] = t.CNilai
	t.fieldMap["c_kelompok"] = t.CKelompok
	t.fieldMap["c_sesi"] = t.CSesi
	t.fieldMap["c_tgl_upload"] = t.CTglUpload
	t.fieldMap["c_tgl_tampil"] = t.CTglTampil
	t.fieldMap["c_tgl_tutup"] = t.CTglTutup
	t.fieldMap["c_edit_nilai"] = t.CEditNilai
	t.fieldMap["c_updater"] = t.CUpdater
}

func (t tUtbkHeader) clone(db *gorm.DB) tUtbkHeader {
	t.tUtbkHeaderDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tUtbkHeader) replaceDB(db *gorm.DB) tUtbkHeader {
	t.tUtbkHeaderDo.ReplaceDB(db)
	return t
}

type tUtbkHeaderDo struct{ gen.DO }

type ITUtbkHeaderDo interface {
	gen.SubQuery
	Debug() ITUtbkHeaderDo
	WithContext(ctx context.Context) ITUtbkHeaderDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITUtbkHeaderDo
	WriteDB() ITUtbkHeaderDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITUtbkHeaderDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITUtbkHeaderDo
	Not(conds ...gen.Condition) ITUtbkHeaderDo
	Or(conds ...gen.Condition) ITUtbkHeaderDo
	Select(conds ...field.Expr) ITUtbkHeaderDo
	Where(conds ...gen.Condition) ITUtbkHeaderDo
	Order(conds ...field.Expr) ITUtbkHeaderDo
	Distinct(cols ...field.Expr) ITUtbkHeaderDo
	Omit(cols ...field.Expr) ITUtbkHeaderDo
	Join(table schema.Tabler, on ...field.Expr) ITUtbkHeaderDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITUtbkHeaderDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITUtbkHeaderDo
	Group(cols ...field.Expr) ITUtbkHeaderDo
	Having(conds ...gen.Condition) ITUtbkHeaderDo
	Limit(limit int) ITUtbkHeaderDo
	Offset(offset int) ITUtbkHeaderDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITUtbkHeaderDo
	Unscoped() ITUtbkHeaderDo
	Create(values ...*model.TUtbkHeader) error
	CreateInBatches(values []*model.TUtbkHeader, batchSize int) error
	Save(values ...*model.TUtbkHeader) error
	First() (*model.TUtbkHeader, error)
	Take() (*model.TUtbkHeader, error)
	Last() (*model.TUtbkHeader, error)
	Find() ([]*model.TUtbkHeader, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUtbkHeader, err error)
	FindInBatches(result *[]*model.TUtbkHeader, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TUtbkHeader) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITUtbkHeaderDo
	Assign(attrs ...field.AssignExpr) ITUtbkHeaderDo
	Joins(fields ...field.RelationField) ITUtbkHeaderDo
	Preload(fields ...field.RelationField) ITUtbkHeaderDo
	FirstOrInit() (*model.TUtbkHeader, error)
	FirstOrCreate() (*model.TUtbkHeader, error)
	FindByPage(offset int, limit int) (result []*model.TUtbkHeader, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITUtbkHeaderDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tUtbkHeaderDo) Debug() ITUtbkHeaderDo {
	return t.withDO(t.DO.Debug())
}

func (t tUtbkHeaderDo) WithContext(ctx context.Context) ITUtbkHeaderDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tUtbkHeaderDo) ReadDB() ITUtbkHeaderDo {
	return t.Clauses(dbresolver.Read)
}

func (t tUtbkHeaderDo) WriteDB() ITUtbkHeaderDo {
	return t.Clauses(dbresolver.Write)
}

func (t tUtbkHeaderDo) Session(config *gorm.Session) ITUtbkHeaderDo {
	return t.withDO(t.DO.Session(config))
}

func (t tUtbkHeaderDo) Clauses(conds ...clause.Expression) ITUtbkHeaderDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tUtbkHeaderDo) Returning(value interface{}, columns ...string) ITUtbkHeaderDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tUtbkHeaderDo) Not(conds ...gen.Condition) ITUtbkHeaderDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tUtbkHeaderDo) Or(conds ...gen.Condition) ITUtbkHeaderDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tUtbkHeaderDo) Select(conds ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tUtbkHeaderDo) Where(conds ...gen.Condition) ITUtbkHeaderDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tUtbkHeaderDo) Order(conds ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tUtbkHeaderDo) Distinct(cols ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tUtbkHeaderDo) Omit(cols ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tUtbkHeaderDo) Join(table schema.Tabler, on ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tUtbkHeaderDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tUtbkHeaderDo) RightJoin(table schema.Tabler, on ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tUtbkHeaderDo) Group(cols ...field.Expr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tUtbkHeaderDo) Having(conds ...gen.Condition) ITUtbkHeaderDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tUtbkHeaderDo) Limit(limit int) ITUtbkHeaderDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tUtbkHeaderDo) Offset(offset int) ITUtbkHeaderDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tUtbkHeaderDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITUtbkHeaderDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tUtbkHeaderDo) Unscoped() ITUtbkHeaderDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tUtbkHeaderDo) Create(values ...*model.TUtbkHeader) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tUtbkHeaderDo) CreateInBatches(values []*model.TUtbkHeader, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tUtbkHeaderDo) Save(values ...*model.TUtbkHeader) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tUtbkHeaderDo) First() (*model.TUtbkHeader, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUtbkHeader), nil
	}
}

func (t tUtbkHeaderDo) Take() (*model.TUtbkHeader, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUtbkHeader), nil
	}
}

func (t tUtbkHeaderDo) Last() (*model.TUtbkHeader, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUtbkHeader), nil
	}
}

func (t tUtbkHeaderDo) Find() ([]*model.TUtbkHeader, error) {
	result, err := t.DO.Find()
	return result.([]*model.TUtbkHeader), err
}

func (t tUtbkHeaderDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUtbkHeader, err error) {
	buf := make([]*model.TUtbkHeader, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tUtbkHeaderDo) FindInBatches(result *[]*model.TUtbkHeader, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tUtbkHeaderDo) Attrs(attrs ...field.AssignExpr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tUtbkHeaderDo) Assign(attrs ...field.AssignExpr) ITUtbkHeaderDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tUtbkHeaderDo) Joins(fields ...field.RelationField) ITUtbkHeaderDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tUtbkHeaderDo) Preload(fields ...field.RelationField) ITUtbkHeaderDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tUtbkHeaderDo) FirstOrInit() (*model.TUtbkHeader, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUtbkHeader), nil
	}
}

func (t tUtbkHeaderDo) FirstOrCreate() (*model.TUtbkHeader, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUtbkHeader), nil
	}
}

func (t tUtbkHeaderDo) FindByPage(offset int, limit int) (result []*model.TUtbkHeader, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tUtbkHeaderDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tUtbkHeaderDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tUtbkHeaderDo) Delete(models ...*model.TUtbkHeader) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tUtbkHeaderDo) withDO(do gen.Dao) *tUtbkHeaderDo {
	t.DO = *do.(*gen.DO)
	return t
}
